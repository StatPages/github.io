<HTML>
<HEAD>
  <META http-equiv="PICS-Label" content='(PICS-1.0 "http://www.classify.org/safesurf/" l on "1996.08.22T13:44+0000 r (SS~~000 1)'>
  <SCRIPT language="JavaScript">
<!-- hide this script tag's contents from old browsers

var Pi=Math.PI; var PiD2=Pi/2; var PiD4=Pi/4; var Pi2=2*Pi
var Deg=180/Pi

function Fact(n) {
    if(n==0) { return 1 }
    if(n<0 & n>-1) { n=n+1; return Math.exp((n+0.5)*Math.log(n+1)-n-n*(0.1121105+n*0.08106103)/(1.452342+n*(2.410858+n)))/n }
    var a=0; if(n<0) { n=Math.abs(n)-1; a=1 }
    var r=n
    if((n%1)==0) { while(n>1) { n=n-1; r=r*n } }
        else { r=Math.exp(Math.abs((n+0.5)*Math.log(n+1)-n-n*(0.1121105+n*0.08106103)/(1.452342+n*(2.410858+n)))) }
    if(a==1) { r=-Pi/(r*Math.sin(Pi*n)) }
    return r
    }

function Abs(x) { return Math.abs(x) }
function Sqrt(x) { return Math.sqrt(x) }
function Exp(x) { return Math.exp(x) }
function Ln(x) { return Math.log(x) }
function Log10(x) { return Math.log(x)/Math.log(10) }
function Log2(x) { return Math.log(x)/Math.log(2) }
function Power(x,y) { return Math.pow(x,y) }
function Sin(x) { return Math.sin(x) }
function Cos(x) { return Math.cos(x) }
function Tan(x) { return Math.sin(x)/Math.cos(x) }
function Cot(x) { return Math.cos(x)/Math.sin(x) }
function Sec(x) { return 1/Math.cos(x) }
function Csc(x) { return 1/Math.sin(x) }
function ATan(x) { return Math.atan(x) }
function ASin(x) { return Math.asin(x) }
function ACos(x) { return Math.acos(x) }
function ACot(x) { return ATan(1/x) }
function ASec(x) { return ACos(1/x) }
function ACsc(x) { return ASin(1/x) }

function SinH(x) { return (Math.exp(x)-Math.exp(-x))/2 }
function CosH(x) { return (Math.exp(x)+Math.exp(-x))/2 }
function TanH(x) { return SinH(x)/CosH(x) }
function CotH(x) { return 1/TanH(x) }
function SecH(x) { return 1/CosH(x) }
function CscH(x) { return 1/SinH(x) }
function ASinH(x) { return Math.log(x+Math.sqrt(x*x+1)) }
function ACosH(x) { return Math.log(x+Math.sqrt(x*x-1)) }
function ATanH(x) { return 0.5*Math.log((1+x)/(1-x)) }
function ACotH(x) { return 0.5*Math.log((x+1)/(x-1)) }
function ASecH(x) { return Math.log(1/x+Math.sqrt(1/(x*x)+1)) }
function ACscH(x) { return Math.log(1/x+Math.sqrt(1/(x*x)-1)) }

function ChiSq(x,n) {
    var p=Math.exp(-0.5*x); if((n%2)==1) { p=p*Math.sqrt(2*x/Pi) }
    var k=n; while(k>=2) { p=p*x/k; k=k-2 }
    var t=p; var a=n; while(t>0.000001*p) { a=a+2; t=t*x/a; p=p+t }
    return 1-p
    }
function Norm(z) { return ChiSq(z*z,1) }
function Gauss(z) { return (z<0)? ChiSq(z*z,1)/2:1-ChiSq(z*z,1)/2 }
function StudT(t,n) {
    t=Math.abs(t); var w=t/Math.sqrt(n); var th=Math.atan(w)
    if(n==1) { return 1-th/PiD2 }
    var sth=Math.sin(th); var cth=Math.cos(th)
    if((n%2)==1)
        { return 1-(th+sth*cth*StatCom(cth*cth,2,n-3,-1))/PiD2 }
        else
        { return 1-sth*StatCom(cth*cth,1,n-3,-1) }
    }
function FishF(f,n1,n2) {
    var x=n2/(n1*f+n2)
    if((n1%2)==0) { return StatCom(1-x,n2,n1+n2-4,n2-2)*Math.pow(x,n2/2) }
    if((n2%2)==0){ return 1-StatCom(x,n1,n1+n2-4,n1-2)*Math.pow(1-x,n1/2) }
    var th=Math.atan(Math.sqrt(n1*f/n2)); var a=th/PiD2; var sth=Math.sin(th); var cth=Math.cos(th)
    if(n2>1) { a=a+sth*cth*StatCom(cth*cth,2,n2-3,-1)/PiD2 }
    if(n1==1) { return 1-a }
    var c=4*StatCom(sth*sth,n2+1,n1+n2-4,n2-2)*sth*Math.pow(cth,n2)/Pi
    if(n2==1) { return 1-a+c/2 }
    var k=2; while(k<=(n2-1)/2) {c=c*k/(k-.5); k=k+1 }
    return 1-a+c
    }
function StatCom(q,i,j,b) {
    var zz=1; var z=zz; var k=i; while(k<=j) { zz=zz*q*k/(k-b); z=z+zz; k=k+2 }
    return z
    }
function ANorm(p) { var v=0.5; var dv=0.5; var z=0
    while(dv>1e-6) { z=1/v-1; dv=dv/2; if(Norm(z)>p) { v=v-dv } else { v=v+dv } }
    return z
    }
function AChiSq(p,n) { var v=0.5; var dv=0.5; var x=0
    while(dv>1e-6) { x=1/v-1; dv=dv/2; if(ChiSq(x,n)>p) { v=v-dv } else { v=v+dv } }
    return x
    }
function AStudT(p,n) { var v=0.5; var dv=0.5; var t=0
    while(dv>1e-6) { t=1/v-1; dv=dv/2; if(StudT(t,n)>p) { v=v-dv } else { v=v+dv } }
    return t
    }
function AFishF(p,n1,n2) { var v=0.5; var dv=0.5; var f=0
    while(dv>1e-6) { f=1/v-1; dv=dv/2; if(FishF(f,n1,n2)>p) { v=v-dv } else { v=v+dv } }
    return f
    }
function Max(x1,x2) { return (x1>x2)?x1:x2 }
function Min(x1,x2) { return (x1<x2)?x1:x2 }

function Fmt(x) { var v;
	if(Abs(x)<0.00005) { x=0 }
	if(x>=0) { v='          '+(x+0.00005) } else { v='          '+(x-0.00005) }
	v = v.substring(0,v.indexOf('.')+5)
	return v.substring(v.length-10,v.length)
	}

function vFmt(x) { var v;
	if(Abs(x)<0.0000005) { x=0 }
	if(x>=0) { v='              '+(x+0.0000005) } else { v='          '+(x-0.0000005) }
	v = v.substring(0,v.indexOf('.')+7)
	return v.substring(v.length-14,v.length)
	}

function Xlate(s,from,to) { var v = s;
	var l=v.indexOf(from);
	while(l>-1) {
		v = v.substring(0,l) + to + v.substring(l+1,v.length);
		l=v.indexOf(from)
		}
	return v
    }
function createArray() {
	this.length = createArray.arguments.length
	for (var i = 0; i < this.length; i++) { this[i] = createArray.arguments[i] }
	}

function ix(j,k) { return j*(nPar+1)+k }

var Par = new createArray(0,0,0,0,0,0,0,0);
var SEP = new createArray(1,1,1,1,1,1,1,1);
var Der = new createArray(0,0,0,0,0,0,0,0,0);
var Arr = new createArray(0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0);
var Cov = new createArray(0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,0  );
var xyw = new createArray(0,0,0,0,0,0,0,0,0);

var CR = unescape("%0D");
var LF = unescape("%0A");
var Tb = unescape("%09");
var NL = CR + LF;

var i = 0; var j = 0; var k = 0; var l = 0; var m = 0;

var nPar = 0;
var nVar = 0;
var nPts = 0;

var ccSW = 1;
var ccAv = 0;
var ccSD = 1;

function Iterate(form) {

var cccSW = 0;
var cccAv = 0;
var cccSD = 0;

nPts = eval(form.cPts.value);
nPar = eval(form.cPar.value);
nVar = eval(form.cVar.value);
dgfr = nPts - nPar;
var St95 = AStudT( 0.05 , dgfr );

var a = eval(form.ca.value); var p1 = a; Par[0] = a;
var b = eval(form.cb.value); var p2 = b; Par[1] = b;
var c = eval(form.cc.value); var p3 = c; Par[2] = c;
var d = eval(form.cd.value); var p4 = d; Par[3] = d;
var e = eval(form.ce.value); var p5 = e; Par[4] = e;
var f = eval(form.cf.value); var p6 = f; Par[5] = f;
var g = eval(form.cg.value); var p7 = g; Par[6] = g;
var h = eval(form.ch.value); var p8 = h; Par[7] = h;

var da = Xlate(form.data.value,Tb,",");
form.data.value = da;
if( da.indexOf(NL)==-1 ) { if( da.indexOf(CR)>-1 ) { NL = CR } else { NL = LF } }

var o = "y = " + form.funct.value + NL
for (i=1; i<=nVar; i++) {o = o + "     x" + i + "   "}
o = o + "     y         yc       y-yc      SEest      YcLo      YcHi  " + NL;

var RMS = 0;

for (j = 0; j<nPar*(nPar+1); j++) { Arr[j] = 0; }
for (i = 1; i<=nPts; i++) {
	l = da.indexOf(NL); if( l==-1 ) { l = da.length };
	var v = da.substring(0,l);
	da = da.substring(l+NL.length,da.length);
	for (j = 0; j<=nVar; j++) {
		l = v.indexOf(","); if( l==-1 ) { l = v.length };
		xyw[j] = eval(v.substring(0,l));
		o = o + Fmt(xyw[j]);
		v = v.substring(l+1,v.length);
		}

	var y = xyw[nVar]; xyw[nVar] = 0; var yo = y;

	if(v.length==0) { var w = 0 } else { var w = eval(v) }
	w = eval(form.SEy[form.SEy.selectedIndex].value)
	if(w==0) { w = 1 }

	if(nVar>=1) {var x1 = xyw[0]} else {var x1 = 0 }
	if(nVar>=2) {var x2 = xyw[1]} else {var x2 = 0 }
	if(nVar>=3) {var x3 = xyw[2]} else {var x3 = 0 }
	if(nVar>=4) {var x4 = xyw[3]} else {var x4 = 0 }
	if(nVar>=5) {var x5 = xyw[4]} else {var x5 = 0 }
	if(nVar>=6) {var x6 = xyw[5]} else {var x6 = 0 }
	if(nVar>=7) {var x7 = xyw[6]} else {var x7 = 0 }
	if(nVar>=8) {var x8 = xyw[7]} else {var x8 = 0 }
	var x = x1;

	var yTr = form.yTrans[form.yTrans.selectedIndex].text;
	var yT = eval( yTr );
	if(yTr=="Ln(y)") { w = w / y }
	if(yTr=="Sqrt(y)") { w = w / yT }
	if(yTr=="1/y") { w = w / y*y }
	y = yT;

	x1 = eval( form.x1Trans[form.x1Trans.selectedIndex].text ); x = x1;
	x2 = eval( form.x2Trans[form.x2Trans.selectedIndex].text );
	x3 = eval( form.x3Trans[form.x3Trans.selectedIndex].text );
	x4 = eval( form.x4Trans[form.x4Trans.selectedIndex].text );
	x5 = eval( form.x5Trans[form.x5Trans.selectedIndex].text );
	x6 = eval( form.x6Trans[form.x6Trans.selectedIndex].text );
	x7 = eval( form.x7Trans[form.x7Trans.selectedIndex].text );
	x8 = eval( form.x8Trans[form.x8Trans.selectedIndex].text );

	var yc = eval( form.funct.value );

	cccSW = cccSW + 1 / ( w * w );
	cccAv = cccAv + yc / ( w * w );
	cccSD = cccSD + ( y - ccAv ) * ( y - ccAv ) / ( w * w );

	for (var j=0; j<nPar; j++) {
		var Save = Par[j]; if(Save==0) {var Del = 0.0001} else {var Del = Save/1000}
		Par[j] = Save + Del;
		a=Par[0]; b=Par[1]; c=Par[2]; d=Par[3]; e=Par[4]; f=Par[5]; g=Par[6]; h=Par[7];
		p1=a; p2=b; p3=c; p4=d; p5=e; p6=f; p7=g; p8=h;
		Der[j] = ( eval( form.funct.value ) - yc ) / ( Del * w );
		Par[j] = Save;
		a=Par[0]; b=Par[1]; c=Par[2]; d=Par[3]; e=Par[4]; f=Par[5]; g=Par[6]; h=Par[7];
		p1=a; p2=b; p3=c; p4=d; p5=e; p6=f; p7=g; p8=h;
		}
	Der[nPar] = (y - yc) / w;
	RMS = RMS + Der[nPar]*Der[nPar];
	for (j=0; j<nPar; j++) {
		for (k=0; k<=nPar; k++) {
			Arr[ix(j,k)] = Arr[ix(j,k)] + Der[j] * Der[k]
			}
		}
	var SEest = 0;
	for (j=0; j<nPar; j++) {
		SEest = SEest + Cov[ix(j,j)] * Der[j] * Der[j];
		for (k=j+1; k<nPar; k++) {
			SEest = SEest + 2 * Cov[ix(j,k)] * Der[j] * Der[k];
			}
		}
	SEest=w*Sqrt(SEest);
	var yco=yc; var ycl=yc-St95*SEest; var ych=yc+St95*SEest;
	if(yTr=="Ln(y)") { yco=Exp(yc); ycl=Exp(ycl); ych=Exp(ych) }
	if(yTr=="Sqrt(y)") { yco=yc*yc; ycl=ycl*ycl; ych=ych*ych }
	if(yTr=="1/y") { yco=1/yc; ycl=1/ycl; ych=1/ych }

	o = o + (Fmt(yco) + Fmt(yo-yco) + Fmt(SEest) + Fmt(ycl) + Fmt(ych) + NL);

	}

ccSW = cccSW;
ccAv = cccAv / ccSW;
ccSD = cccSD / ccSW;
var GenR2 = (ccSD-(RMS/ccSW))/ccSD;
var GenR = Sqrt(GenR2);
o = o + ( NL + "Corr. Coeff. = " + vFmt(GenR) + ";  r*r = " + vFmt(GenR2) );

RMS = Sqrt(RMS/Max(1,dgfr));
o = o + ( NL + "RMS Error = " + vFmt(RMS) + ";  d.f = " + dgfr + NL );

for (i=0; i<nPar; i++) { var s = Arr[ix(i,i)]; Arr[ix(i,i)] = 1;
	for (k=0; k<=nPar; k++) { Arr[ix(i,k)] = Arr[ix(i,k)] / s; }
	for (j=0; j<nPar; j++) {
		if (i!=j) { s = Arr[ix(j,i)]; Arr[ix(j,i)] = 0;
			for (k=0; k<=nPar; k++) {
				Arr[ix(j,k)] = Arr[ix(j,k)] - s * Arr[ix(i,k)];
				}
			}
		}
	}
var FRelax = eval(form.RelaxF[form.RelaxF.selectedIndex].text)
o = o + ( NL + "Parameter Estimates..." + NL );
for( i=0; i<nPar; i++) {
	Par[i] = Par[i] + FRelax * Arr[ix(i,nPar)];
	SEP[i] = RMS * Sqrt(Arr[ix(i,i)]);
	o = o + ( "p" + (i+1) + "=" + vFmt(Par[i]) + " +/- " + vFmt(SEP[i]) + "; p=" + Fmt(StudT(Par[i]/SEP[i],dgfr)) + NL );
	}

o = o + ( NL + "Covariance Matrix Terms..." + NL );
for (j=0; j<nPar; j++) {
	for (k=j; k<nPar; k++) {
		Cov[ix(j,k)] = Arr[ix(j,k)] * RMS * RMS;
		o = o + ( "B(" + (j+1) + "," + (k+1) + ") = " );
		if(j==k) { o = o + ( "         " ) }
			else { o = o + ( "B(" + (k+1) + "," + (j+1) + ") = " ) }
		o = o + Cov[ix(j,k)];
		v = Fmt(Cov[ix(j,k)]/Sqrt(Cov[ix(j,j)]*Cov[ix(k,k)]))
		if (j!=k) { o = o + ("; r=" + v.substring(v.length-7,v.length)) };
		o = o + NL;
		}
	}

form.output.value = o;

form.ca.value = "" + Par[0]; form.sa.value = "" + SEP[0]; form.pva.value = vFmt(StudT(Par[0]/SEP[0],dgfr));
form.cb.value = "" + Par[1]; form.sb.value = "" + SEP[1]; form.pvb.value = vFmt(StudT(Par[1]/SEP[1],dgfr));
form.cc.value = "" + Par[2]; form.sc.value = "" + SEP[2]; form.pvc.value = vFmt(StudT(Par[2]/SEP[2],dgfr));
form.cd.value = "" + Par[3]; form.sd.value = "" + SEP[3]; form.pvd.value = vFmt(StudT(Par[3]/SEP[3],dgfr));
form.ce.value = "" + Par[4]; form.se.value = "" + SEP[4]; form.pve.value = vFmt(StudT(Par[4]/SEP[4],dgfr));
form.cf.value = "" + Par[5]; form.sf.value = "" + SEP[5]; form.pvf.value = vFmt(StudT(Par[5]/SEP[5],dgfr));
form.cg.value = "" + Par[6]; form.sg.value = "" + SEP[6]; form.pvg.value = vFmt(StudT(Par[6]/SEP[6],dgfr));
form.ch.value = "" + Par[7]; form.sh.value = "" + SEP[7]; form.pvh.value = vFmt(StudT(Par[7]/SEP[7],dgfr));

form.cRMS.value = "" + RMS;
}		

<!-- done hiding from old browsers -->
</SCRIPT>
  <TITLE>Nonlinear Least Squares Model Library</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffee">
<CENTER>
  <H2>
    <FONT COLOR="Red">Model Library</FONT>
  </H2>
  <H4>
    <FONT COLOR="Red">for the Nonlinear Least Squares Curve Fitter</FONT>
  </H4>
  <P>
  <SMALL><I>Revised 03/24/2000</I></SMALL>
  <P>
</CENTER>
<P>
This page contains a large collection of "models", or functions, that arise
in linear and nonlinear curve fitting. For each function, there is a short
description of the model, followed by a table showing what has to be entered
into the curve fitting page. You can copy and paste the function from this
page into the function box on the curve fitting page.
<P>
  <HR>
<H3>
  <FONT COLOR="Red">Simple linear models:</FONT>
</H3>
<P>
Lin1: <FONT COLOR="Red">Straight line</FONT>. This is the classic least squares
straight line. There are many web pages that fit straight lines. One reason
for using the Nonlinear Curve Fitter is for the extra information it provides:
parameter error estimates, confidence bands, etc.
<TABLE BORDER CELLPADDING="2">
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Independent Variables:</TD>
    <TD>1</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Parameters:</TD>
    <TD>2</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Function to be fitted: y=</TD>
    <TD>a + b * x</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Initial Parameter Guesses:</TD>
    <TD>a=0, b=0 (convergence is guaranteed)</TD>
  </TR>
</TABLE>
<P>
Lin2: <FONT COLOR="Red">Straight line passing through the origin</FONT>.
This model does not include the "intercept", or "constant term". It should
be used only when you know that the fitted line must pass through the origin.
<TABLE BORDER CELLPADDING="2">
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Independent Variables:</TD>
    <TD>1</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Parameters:</TD>
    <TD>1</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Function to be fitted: y=</TD>
    <TD>a * x</TD>
  </TR>
  <TR VALIGN="Top">
    <TD>Initial Parameter Guesses:</TD>
    <TD>a=0 (convergence is guaranteed)</TD>
  </TR>
</TABLE>
<P>
Lin3: <FONT COLOR="Red">Horizontal Straight Line</FONT>. This model is so
trivially simple that it's almost never used. In fact, it hardly fits into
the category of "curve fitting" because there's really no curve involved
at all. Basically, you would be using the web page to compute simple "descriptive
statistics" on a set of numbers.
<TABLE BORDER CELLPADDING="2">
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Independent Variables:</TD>
    <TD>0</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Parameters:</TD>
    <TD>1</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Function to be fitted: y=</TD>
    <TD>a</TD>
  </TR>
  <TR VALIGN="Top">
    <TD>Initial Parameter Guesses:</TD>
    <TD>a=0 (convergence is guaranteed)</TD>
  </TR>
</TABLE>
<P>
Lin4: <FONT COLOR="Red">Parabola</FONT>. This model can be used to test for
significant non-linearity in the data (in which case the c parameter will
be significantly different from zero).
<TABLE BORDER CELLPADDING="2">
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Independent Variables:</TD>
    <TD>1</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Parameters:</TD>
    <TD>3</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Function to be fitted: y=</TD>
    <TD>a + b * x + c * x*x</TD>
  </TR>
  <TR VALIGN="Top">
    <TD>Initial Parameter Guesses:</TD>
    <TD>a,b,c=0 (convergence is guaranteed)</TD>
  </TR>
</TABLE>
<P>
Lin5: <FONT COLOR="Red">Polynomial</FONT>. This fits any polynomial up to
7 order. The function below may not look like a polynomial because it is
written in "factored" form, which is more efficient to compute than the usual
form. <FONT COLOR="Purple">Note: Never fit a parabola to data that "levels
off" horizontally for large or small values of x.</FONT>
<TABLE BORDER CELLPADDING="2">
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Independent Variables:</TD>
    <TD>1</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Parameters:</TD>
    <TD>anything from 1 through 8 (1 = constant; 2 = straight line; 3 = parabola;
      4 = cubic; 5 = quartic; etc.</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Function to be fitted: y=</TD>
    <TD>a + x*(b + x*(c + x*(d + x*(e + x*(f + x*(g + x*h))))))</TD>
  </TR>
  <TR VALIGN="Top">
    <TD>Initial Parameter Guesses:</TD>
    <TD>all=0 (convergence is guaranteed). Be sure to set all parameter guesses
      to zero, especially the "extra" parameters beyond what you're fitting, or
      the results will be incorrect.</TD>
  </TR>
</TABLE>
<P>
Lin6: <FONT COLOR="Red">Multivariate linear regression</FONT>.
<TABLE BORDER CELLPADDING="2">
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Independent Variables:</TD>
    <TD>anything from 1 through 7</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Parameters:</TD>
    <TD>anything from 1 through 8</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Function to be fitted: y=</TD>
    <TD>a + b*x1 + c*x2 + d*x3 + e*x4 + f*x5 + g*x6 + h*x7</TD>
  </TR>
  <TR VALIGN="Top">
    <TD>Initial Parameter Guesses:</TD>
    <TD>all=0 (convergence is guaranteed). Be sure to set all parameter guesses
      to zero, especially the "extra" parameters beyond what you're fitting, or
      the results will be incorrect.</TD>
  </TR>
</TABLE>
<P>
  <HR>
<H3>
  <FONT COLOR="Red"> Exponential Decay Curves:</FONT>
</H3>
<P>
Exp1: <FONT COLOR="Red">Single Exponential decay to zero</FONT>. This is
the basic fit for exponential decay. It would be used for data that would
be a straight line on semi-log graph paper.
<TABLE BORDER CELLPADDING="2">
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Independent Variables:</TD>
    <TD>1</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Parameters:</TD>
    <TD>2</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Function to be fitted: y=</TD>
    <TD>a * Exp(- b * t )</TD>
  </TR>
  <TR VALIGN="Top">
    <TD>Initial Parameter Guesses:</TD>
    <TD>a: the value of y when t=0<BR>
      b: the exponential constant; guess 0.7/half-time; positive for a decreasing
      exponential; negative for an increasing exponential.</TD>
  </TR>
</TABLE>
<P>
Exp2: <FONT COLOR="Red">Single Exponential decay to an arbitrary value</FONT>.
This contains an extra parameter to allow for the curve leveling off to a
value different from zero.
<TABLE BORDER CELLPADDING="2">
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Independent Variables:</TD>
    <TD>1</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Parameters:</TD>
    <TD>3</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Function to be fitted: y=</TD>
    <TD>( a - c ) * Exp( - b * t ) + c</TD>
  </TR>
  <TR VALIGN="Top">
    <TD>Initial Parameter Guesses:</TD>
    <TD>a: the value of y when t=0<BR>
      b: the exponential constant; guess 0.7/half-time; positive for a decreasing
      exponential; negative for an increasing exponential<BR>
      c: the "leveling-off" (asymptotic) value, for large t</TD>
  </TR>
</TABLE>
<P>
Exp3: <FONT COLOR="Red">Multiple Exponential decay to zero</FONT>.
<TABLE BORDER CELLPADDING="2">
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Independent Variables:</TD>
    <TD>1</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Parameters:</TD>
    <TD>2 for a single exponential, 4 for a double exponential, 6 for triple,
      or 8 for quadruple.</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Function to be fitted: y=</TD>
    <TD>p1*Exp(-p2*t) + p3*Exp(-p4*t) + p5*Exp(-p6*t) + p7*Exp(-p8*t)</TD>
  </TR>
  <TR VALIGN="Top">
    <TD>Initial Parameter Guesses:</TD>
    <TD>p1, p3, p5, p7: the "amplitudes" of the individual exponential
      components.<BR>
      p2, p4, p6, p8: the corresponding exponential constants; each is equal to
      0.7/half-life for that exponential component.<BR>
      Be sure to set the "extra" parameters (beyond what you're fitting) to zero,
      or the results will be incorrect.</TD>
  </TR>
</TABLE>
<P>
Exp4: <FONT COLOR="Red">Multiple Exponential decay to an arbitrary
value</FONT>.
<TABLE BORDER CELLPADDING="2">
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Independent Variables:</TD>
    <TD>1</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Parameters:</TD>
    <TD>3 for a single exponential, 5 for a double exponential, or 7 for triple</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Function to be fitted: y=</TD>
    <TD>p1 + p2*Exp(-p3*t) + p4*Exp(-p5*t) + p6*Exp(-p7*t)</TD>
  </TR>
  <TR VALIGN="Top">
    <TD>Initial Parameter Guesses:</TD>
    <TD>p1: the leveling-off value for large t<BR>
      p2, p4, p6: the "amplitudes" of the individual exponential components.<BR>
      p3, p5, p7: the corresponding exponential constants; each is equal to
      0.7/half-life for that exponential component.</TD>
  </TR>
</TABLE>
<P>
Exp5: <FONT COLOR="Red">Half-life form, decay to zero</FONT>: This model
is algebraically equivalent to the "single exponential decay to zero" model,
but directly produces the half-time estimate instead of the rate constant.
<TABLE BORDER CELLPADDING="2">
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Independent Variables:</TD>
    <TD>1</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Parameters:</TD>
    <TD>2</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Function to be fitted: y=</TD>
    <TD>a / Power( 2 , t/b )</TD>
  </TR>
  <TR VALIGN="Top">
    <TD>Initial Parameter Guesses:</TD>
    <TD>a: the value of y when t=0<BR>
      b: the half-time</TD>
  </TR>
</TABLE>
<P>
Exp6: <FONT COLOR="Red">Half-life form, decay to an arbitrary value</FONT>.
This model is algebraically equivalent to the "single exponential decay to
an arbitrary value" model, but directly produces the half-time estimate instead
of the rate constant.
<TABLE BORDER CELLPADDING="2">
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Independent Variables:</TD>
    <TD>1</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Parameters:</TD>
    <TD>3</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Function to be fitted: y=</TD>
    <TD>( a - c ) / Power( 2 , t/b ) + c</TD>
  </TR>
  <TR VALIGN="Top">
    <TD>Initial Parameter Guesses:</TD>
    <TD>a: the value of y when t=0<BR>
      b: the half-time<BR>
      c: the "leveling-off" (asymptotic) value, for large t</TD>
  </TR>
</TABLE>
<P>
  <HR>
<H3>
  <FONT COLOR="Red">Temperature-dependence Models</FONT>
</H3>
<P>
Temp1: <FONT COLOR="Red">log-vs-reciprocal</FONT>. Y is some
temperature-dependent quantity; t is the absolute temperature (usually degrees
Kelvin).
<TABLE BORDER CELLPADDING="2">
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Independent Variables:</TD>
    <TD>1</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Parameters:</TD>
    <TD>2</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Function to be fitted: y=</TD>
    <TD>Exp( a - b / t )</TD>
  </TR>
  <TR VALIGN="Top">
    <TD>Initial Parameter Guesses:</TD>
    <TD>a: empirical; value depends on units of t and y<BR>
      b: usually related to an energy of activation for some underlying process</TD>
  </TR>
</TABLE>
<P>
Temp2: <FONT COLOR="Red">Antoine Equation</FONT>. An empirical extension
of the log-reciprocal model, containing an extra parameter. t is usually
given in degrees celsius, not absolute temperature.
<TABLE BORDER CELLPADDING="2">
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Independent Variables:</TD>
    <TD>1</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Parameters:</TD>
    <TD>3</TD>
  </TR>
  <TR VALIGN="Top">
    <TD><P ALIGN=Right>
      Function to be fitted: y=</TD>
    <TD>Exp( a - b/(x+c) )</TD>
  </TR>
  <TR VALIGN="Top">
    <TD>Initial Parameter Guesses:</TD>
    <TD>a: empirical; value depends on units of x and y<BR>
      b: usually related to an energy of activation for some underlying process<BR>
      c: an empirical parameter, usually near 273 for celsius t.</TD>
  </TR>
</TABLE>
<P>
  <HR>
<H3>
  <FONT COLOR="Red">Growth Curves:</FONT>
</H3>
<P>
Logit Equation.
<P>
Probit Equation.
<P>
Rossevik Curve for Fetal Growth
<P>
Simple ascending asymptotic growth
<P>
Simple descending asymptotic growth
<P>
  <HR>
<H3>
  <FONT COLOR="Red">Pharmacokinetic Models:</FONT>
</H3>
<P>
Michaelis-Menten.
<P>
One compartment, bolus dose
<P>
One compartment, continuous infusion
<P>
etc., etc.
<P>
<P>
  <HR>
<P ALIGN=Center>
Return to the <A HREF="nonlin.html">Non-linear Curve-fitting Page</A>, or
to the <A HREF="index.html">Interactive Statistics page</A> or to the
<A HREF="JCPhome.html">JCP Home Page</A><BR>
<BR>
Send e-mail to John C. Pezzullo at
<IMG SRC="emladr.gif" WIDTH="217" HEIGHT="24" BORDER="0" ALIGN="Middle">
</BODY></HTML>
